package uk.gov.dwp.jsa.citizen_ui.model;

import org.springframework.data.annotation.Id;
import org.springframework.data.redis.core.RedisHash;
import org.springframework.util.Assert;
import uk.gov.dwp.jsa.adaptors.enums.ClaimType;
import uk.gov.dwp.jsa.citizen_ui.Constants;
import uk.gov.dwp.jsa.citizen_ui.controller.BankAccountFormController;
import uk.gov.dwp.jsa.citizen_ui.controller.availability.AttendInterviewController;
import uk.gov.dwp.jsa.citizen_ui.controller.claimstart.ClaimStartDateController;
import uk.gov.dwp.jsa.citizen_ui.controller.personaldetails.DateOfBirthFormController;
import uk.gov.dwp.jsa.citizen_ui.controller.personaldetails.PersonalDetailsFormController;
import uk.gov.dwp.jsa.citizen_ui.model.form.BankAccountQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.ClaimStartDateQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.DeclarationQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.Question;
import uk.gov.dwp.jsa.citizen_ui.model.form.availability.AttendInterviewQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.common.BooleanQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.common.DateQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.common.GuardQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.common.MultipleOptionsQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.common.QuestionHolder;
import uk.gov.dwp.jsa.citizen_ui.model.form.currentwork.CurrentWork;
import uk.gov.dwp.jsa.citizen_ui.model.form.education.EducationDetails;
import uk.gov.dwp.jsa.citizen_ui.model.form.eligibility.ActivelyLookingWorkQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.eligibility.AgeQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.eligibility.AreYouWorkingQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.eligibility.ContributionQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.eligibility.HoursWorkingPerWeekQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.eligibility.ResidenceQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.personaldetails.DateOfBirthQuestion;
import uk.gov.dwp.jsa.citizen_ui.model.form.personaldetails.PersonalDetailsQuestion;
import uk.gov.dwp.jsa.citizen_ui.routing.Step;
import uk.gov.dwp.jsa.citizen_ui.routing.StepInstance;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.apache.commons.lang3.builder.EqualsBuilder.reflectionEquals;
import static org.apache.commons.lang3.builder.HashCodeBuilder.reflectionHashCode;
import static org.apache.commons.lang3.builder.ToStringBuilder.reflectionToString;
import static uk.gov.dwp.jsa.citizen_ui.Constants.NO_ALTERNATIVE_IDENTIFIER;
import static uk.gov.dwp.jsa.citizen_ui.controller.Section.NONE;

/**
 * The claim stored in Redis.
 */
@RedisHash(value = "Claim", timeToLive = Constants.REDIS_TTL)
public class Claim {
    private static final String STEP_INSTANCE_CANNOT_BE_NULL = "StepInstance cannot be null";
    private static final String IDENTIFIER_CANNOT_BE_NULL = "Identifier cannot be null";
    private static final String IDENTIFIER_CANNOT_BE_EMPTY = "Identifier cannot be empty";
    /**
     * Map holding answers to questions.
     */
    private Map<Integer, Question> answers = new HashMap<>();

    private ClaimType claimType;

    private String claimantId;

    private LocalDateTime claimantLatestActivity;
    /**
     * Autogenerated id from Redis.
     */
    @Id
    private String id;
    /**
     * Q3 The date of claim.
     */
    private ClaimStartDateQuestion claimStartDateQuestion;
    /**
     * Declaration question response.
     */
    private DeclarationQuestion declarationQuestion;
    /**
     * EQ1 Eligibility residence question.
     */
    private ResidenceQuestion residenceQuestion;
    /**
     * EQ2 Eligibility Are you aged 18 or over.
     */
    private AgeQuestion ageQuestion;
    /**
     * EQ3 Eligibility Are You Working Question.
     */
    private AreYouWorkingQuestion areYouWorkingQuestion;
    /**
     * EQ4 Eligibility Hours Working Per Week Question.
     */
    private HoursWorkingPerWeekQuestion hoursWorkingPerWeekQuestion;
    /**
     * EQ5 Eligibility Are You Actively Looking For Work Question.
     */
    private ActivelyLookingWorkQuestion activelyLookingWorkQuestion;
    /**
     * EQ6 Contributions Question.
     */
    private ContributionQuestion contributionsQuestion;
    /**
     * Q16 Jury service question.
     */
    private BooleanQuestion juryServiceQuestion;
    /**
     * Q17a Jury service start date.
     */
    private DateQuestion juryServiceStartDateQuestion;
    /**
     * Q17b Jury service end date.
     */
    private DateQuestion juryServiceEndDateQuestion;
    /**
     * Q84 Bank Account Details Question.
     */
    private BankAccountQuestion bankAccountQuestion;
    private LocalDate initialDateOfContact;
    private PreviousEmployment previousEmployment;
    private EducationDetails educationDetails;
    private AvailabilityDetails availabilityDetails;
    private PersonalDetails personalDetails;
    private OtherBenefits otherBenefits;
    private CurrentWork currentWork;

    public Claim(final ClaimType claimType) {
        this.claimantLatestActivity = LocalDateTime.now();
        this.claimType = claimType;
    }

    public Claim() {
        this.claimantLatestActivity = LocalDateTime.now();
        this.claimType = ClaimType.NEW_CLAIM;
    }

    /**
     * This function saves a question to the claim.
     *
     * @param stepInstance                  the question's stepInstance
     * @param question                      the question to be saved
     * @param lastGuardStepInstanceOptional the stepInstance for the question's guardQuestion, if any
     */
    public void save(final StepInstance stepInstance,
                     final Question question,
                     final Optional<StepInstance> lastGuardStepInstanceOptional) {
        Assert.notNull(stepInstance, STEP_INSTANCE_CANNOT_BE_NULL);
        Assert.notNull(question, "Question cannot be null");

        if (!lastGuardStepInstanceOptional.isPresent()) {
            answers.put(stepInstance.getClaimKey(), question);
        } else {
            Optional<Question> optionalLastGuardQuestion =
                    search(lastGuardStepInstanceOptional.get(), this.answers);
            saveWithLastGuardQuestion(stepInstance, question, optionalLastGuardQuestion);
        }
    }

    public void setAnswer(final String questionKey, final Question question) {
        answers.put(questionKey.hashCode(), question);
    }

    private void saveWithLastGuardQuestion(final StepInstance stepInstance,
                                           final Question question,
                                           final Optional<Question> optionalLastGuardQuestion) {
        if (optionalLastGuardQuestion.isPresent()) {
            Question q = optionalLastGuardQuestion.get();
            if (q.isADealBreaker()) {
                answers.put(stepInstance.getClaimKey(), question);
            } else {
                if (q instanceof GuardQuestion) {
                    GuardQuestion guardQuestion = (GuardQuestion) q;
                    guardQuestion.getAnswers().put(stepInstance.getClaimKey(), question);
                }

                if (q instanceof MultipleOptionsQuestion) {
                    MultipleOptionsQuestion multipleOptionsQuestion = (MultipleOptionsQuestion) q;
                    multipleOptionsQuestion.getAnswers().put(stepInstance.getClaimKey(), question);
                }
            }
        }
    }

    /**
     * This function traverses the Claim tree to find the question belonging to a stepInstance.
     *
     * @param stepInstance the step instance for the question
     * @param table        the Claim tree
     * @return the question if found
     */
    public Optional<Question> search(final StepInstance stepInstance, final Map<Integer, Question> table) {
        Assert.notNull(stepInstance, STEP_INSTANCE_CANNOT_BE_NULL);

        for (Map.Entry<Integer, Question> entry : table.entrySet()) {
            Integer key = entry.getKey();
            Question currentQuestion = entry.getValue();
            if (stepInstance.getClaimKey().equals(key)) {
                return Optional.ofNullable(table.get(stepInstance.getClaimKey()));
            }

            if (currentQuestion instanceof GuardQuestion) {
                GuardQuestion guardQuestion = (GuardQuestion) currentQuestion;
                Optional<Question> question = search(stepInstance, guardQuestion.getAnswers());
                if (question.isPresent()) {
                    return question;
                }
            }
            if (currentQuestion instanceof MultipleOptionsQuestion) {
                MultipleOptionsQuestion moQuestion = (MultipleOptionsQuestion) currentQuestion;
                Optional question = search(stepInstance, moQuestion.getAnswers());
                if (question.isPresent()) {
                    return question;
                }
            }
        }
        return Optional.empty();
    }

    public Map<Integer, Question> searchForParent(final StepInstance stepInstance, final Map<Integer, Question> table) {
        Assert.notNull(stepInstance, STEP_INSTANCE_CANNOT_BE_NULL);

        for (Map.Entry<Integer, Question> entry : table.entrySet()) {
            Question currentQuestion = entry.getValue();

            if (table.containsKey(stepInstance.getClaimKey())) {
                return table;
            }

            if (currentQuestion instanceof QuestionHolder) {
                QuestionHolder questionHolder = (QuestionHolder) currentQuestion;
                Map<Integer, Question> parent = searchForParent(stepInstance, questionHolder.getAnswers());
                if (parent != null) {
                    return parent;
                }
            }
        }
        return null;
    }

    public void delete(final StepInstance instance, final int loopLimit) {

        final Step step = instance.getStep();

        //remve first one - in case there is only one in list
        Map<Integer, Question> firstQuestions = searchForParent(instance, answers);
        if (firstQuestions != null) {
            firstQuestions.remove(instance.getClaimKey());
        }

        for (int loopCount = instance.getCounter() + 1; loopCount <= loopLimit; loopCount++) {
            final StepInstance currentStepInstance = new StepInstance(step, loopCount, false, false, false);
            Map<Integer, Question> currentQuestions = searchForParent(currentStepInstance, answers);
            if (currentQuestions != null) {

                final Optional<Question> currentQuestion = search(currentStepInstance, answers);
                if (currentQuestion.isPresent()) {
                    final StepInstance previousStepInstance = new StepInstance(step, loopCount - 1, false, false, false);
                    currentQuestions.put(previousStepInstance.getClaimKey(), currentQuestion.get());
                }
                currentQuestions.remove(currentStepInstance.getClaimKey());
            }

        }

    }

    public Optional<Question> get(final StepInstance stepInstance) {
        Assert.notNull(stepInstance, STEP_INSTANCE_CANNOT_BE_NULL);
        return search(stepInstance, answers);
    }

    public Optional<Question> get(final String identifier) {
        Assert.notNull(identifier, IDENTIFIER_CANNOT_BE_NULL);
        Assert.hasText(identifier, IDENTIFIER_CANNOT_BE_EMPTY);

        Step step = new Step(identifier, NO_ALTERNATIVE_IDENTIFIER, NO_ALTERNATIVE_IDENTIFIER, NONE);
        StepInstance stepInstance = new StepInstance(step, 0, false, false, false);

        return get(stepInstance);
    }

    public Optional<Question> get(final String identifier, final int counter) {
        Assert.notNull(identifier, IDENTIFIER_CANNOT_BE_NULL);
        Assert.hasText(identifier, IDENTIFIER_CANNOT_BE_EMPTY);

        Step step = new Step(identifier, NO_ALTERNATIVE_IDENTIFIER, NO_ALTERNATIVE_IDENTIFIER, NONE);
        StepInstance stepInstance = new StepInstance(step, counter, false, false, false);

        return get(stepInstance);
    }

    /**
     * This function returns all instances of a question. It is used for questions that exist in a
     * loop. If a loop as been iterated over 3 times, the returned list will contain 3 questions
     *
     * @param identifier the question's identifier
     * @param limit      the max number of instances that should exist
     * @return all instances of a question
     */
    public List<Question> getAll(final String identifier, final int limit) {
        Assert.notNull(identifier, IDENTIFIER_CANNOT_BE_NULL);
        Assert.hasText(identifier, IDENTIFIER_CANNOT_BE_EMPTY);
        List<Question> questions = new ArrayList<>();

        if (!answers.keySet().isEmpty()) {
            for (int count = 1; count <= limit; count++) {
                Step step = new Step(identifier, NO_ALTERNATIVE_IDENTIFIER, NO_ALTERNATIVE_IDENTIFIER, NONE);
                StepInstance si = new StepInstance(step, count, false, false, false);
                Optional<Question> question = get(si);
                question.ifPresent(questions::add);
            }
        }
        return questions;
    }

    /**
     * This function uses {@link #getAll(String, int)} to return the number of instances of a question that
     * exist.
     *
     * @param identifier Id
     * @param limit Limit
     * See getAll for documentation on how it works
     * @return all instances of a question
     */
    public int count(final String identifier, final int limit) {
        return getAll(identifier, limit).size();
    }

    /**
     * This function returns a type specific version of {@link #get(StepInstance)}.
     *
     * @param stepIdentifier the question's identifier
     * @param loop           the instance(loop count) of the question if it's in a loop, 0 otherwise
     * @param clazz          the class used to cast to a specifc type
     * @param <T>            the type required
     * @return a type specific question
     */
    public <T extends Question> Optional<T> get(final String stepIdentifier, final int loop, final Class<T> clazz) {
        Step step = new Step(stepIdentifier, NO_ALTERNATIVE_IDENTIFIER, NO_ALTERNATIVE_IDENTIFIER, NONE);
        StepInstance stepInstance = new StepInstance(step, loop, false, false, false);
        Optional<Question> question = get(stepInstance);

        if (!question.isPresent()) {
            return Optional.empty();
        }

        try {
            return Optional.of(clazz.cast(question.get()));
        } catch (ClassCastException e) {
            return Optional.empty();
        }
    }

    public <T extends Question> Optional<T> get(final String stepIdentifier, final Class<T> clazz) {
        return get(stepIdentifier, 0, clazz);
    }

    public <T extends Question> List<T> getAll(final String stepIdentifier, final int limit, final Class<T> clazz) {
        Assert.notNull(stepIdentifier, IDENTIFIER_CANNOT_BE_NULL);
        Assert.hasText(stepIdentifier, IDENTIFIER_CANNOT_BE_EMPTY);
        Assert.notNull(clazz, "Clazz cannot be empty");

        List<T> questions = new ArrayList<>();

        for (int i = 0; i < limit; i++) {
            Optional<T> question = get(stepIdentifier, i, clazz);
            if (question.isPresent()) {
                questions.add(question.get());
            }
        }

        return questions;
    }

    public Optional<AttendInterviewQuestion> getAttendInterview() {
        return get(AttendInterviewController.IDENTIFIER, AttendInterviewQuestion.class);
    }

    public DateOfBirthQuestion getDateOfBirth() {
        return get(DateOfBirthFormController.IDENTIFIER, DateOfBirthQuestion.class).orElse(null);
    }

    public PersonalDetailsQuestion getPersonalDetailsQuestion() {
        return get(PersonalDetailsFormController.IDENTIFIER, PersonalDetailsQuestion.class).orElse(null);
    }

    public Optional<ClaimStartDateQuestion> getClaimStartDate() {
        return get(ClaimStartDateController.IDENTIFIER, ClaimStartDateQuestion.class);
    }

    public Optional<BankAccountQuestion> getBankAccount() {
        return get(BankAccountFormController.IDENTIFIER, BankAccountQuestion.class);
    }

    public String getId() {
        return id;
    }

    public void setId(final String id) {
        this.id = id;
    }

    public ClaimStartDateQuestion getClaimStartDateQuestion() {
        return claimStartDateQuestion;
    }

    public void setClaimStartDateQuestion(final ClaimStartDateQuestion claimStartDateQuestion) {
        this.claimStartDateQuestion = claimStartDateQuestion;
    }

    public DeclarationQuestion getDeclarationQuestion() {
        if (declarationQuestion == null) {
            declarationQuestion = new DeclarationQuestion();
        }
        return declarationQuestion;
    }

    public void setDeclarationQuestion(final DeclarationQuestion declarationQuestion) {
        this.declarationQuestion = declarationQuestion;
    }

    public AreYouWorkingQuestion getAreYouWorkingQuestion() {
        return areYouWorkingQuestion;
    }

    public void setAreYouWorkingQuestion(final AreYouWorkingQuestion areYouWorkingQuestion) {
        this.areYouWorkingQuestion = areYouWorkingQuestion;
    }

    public ResidenceQuestion getResidenceQuestion() {
        if (residenceQuestion == null) {
            residenceQuestion = new ResidenceQuestion();
        }
        return residenceQuestion;
    }

    public void setResidenceQuestion(final ResidenceQuestion residenceQuestion) {
        this.residenceQuestion = residenceQuestion;
    }

    public AgeQuestion getAgeQuestion() {
        if (ageQuestion == null) {
            return new AgeQuestion();
        }
        return ageQuestion;
    }

    public void setAgeQuestion(final AgeQuestion ageQuestion) {
        this.ageQuestion = ageQuestion;
    }

    public ActivelyLookingWorkQuestion getActivelyLookingWorkQuestion() {
        return activelyLookingWorkQuestion;
    }

    public void setActivelyLookingWorkQuestion(final ActivelyLookingWorkQuestion activelyLookingWorkQuestion) {
        this.activelyLookingWorkQuestion = activelyLookingWorkQuestion;
    }

    public ContributionQuestion getContributionsQuestion() {
        if (contributionsQuestion == null) {
            contributionsQuestion = new ContributionQuestion();
        }
        return contributionsQuestion;
    }

    public void setContributionsQuestion(final ContributionQuestion contributionsQuestion) {
        this.contributionsQuestion = contributionsQuestion;
    }

    public HoursWorkingPerWeekQuestion getHoursWorkingPerWeekQuestion() {
        if (hoursWorkingPerWeekQuestion == null) {
            hoursWorkingPerWeekQuestion = new HoursWorkingPerWeekQuestion();
        }
        return hoursWorkingPerWeekQuestion;
    }

    public void setHoursWorkingPerWeekQuestion(final HoursWorkingPerWeekQuestion hoursWorkingPerWeekQuestion) {
        this.hoursWorkingPerWeekQuestion = hoursWorkingPerWeekQuestion;
    }

    public BooleanQuestion getJuryServiceQuestion() {
        if (juryServiceQuestion == null) {
            juryServiceQuestion = new BooleanQuestion();
        }
        return juryServiceQuestion;
    }

    public void setJuryServiceQuestion(final BooleanQuestion juryServiceQuestion) {
        this.juryServiceQuestion = juryServiceQuestion;
    }

    public LocalDate getInitialDateOfContact() {
        return initialDateOfContact;
    }

    public void setInitialDateOfContact(final LocalDate initialDateOfContact) {
        this.initialDateOfContact = initialDateOfContact;
    }

    public DateQuestion getJuryServiceStartDateQuestion() {
        if (juryServiceStartDateQuestion == null) {
            return new DateQuestion();
        }
        return juryServiceStartDateQuestion;
    }

    public void setJuryServiceStartDateQuestion(final DateQuestion juryServiceStartDateQuestion) {
        this.juryServiceStartDateQuestion = juryServiceStartDateQuestion;
    }

    public DateQuestion getJuryServiceEndDateQuestion() {
        if (juryServiceEndDateQuestion == null) {
            return new DateQuestion();
        }
        return juryServiceEndDateQuestion;
    }

    public void setJuryServiceEndDateQuestion(final DateQuestion juryServiceEndDateQuestion) {
        this.juryServiceEndDateQuestion = juryServiceEndDateQuestion;
    }

    public PreviousEmployment getPreviousEmployment() {
        if (previousEmployment == null) {
            previousEmployment = new PreviousEmployment();
        }
        return previousEmployment;
    }

    public void setPreviousEmployment(final PreviousEmployment previousEmployment) {
        this.previousEmployment = previousEmployment;
    }

    public BankAccountQuestion getBankAccountQuestion() {
        return bankAccountQuestion;
    }

    public void setBankAccountQuestion(final BankAccountQuestion bankAccountQuestion) {
        this.bankAccountQuestion = bankAccountQuestion;
    }

    public AvailabilityDetails getAvailabilityDetails() {
        if (availabilityDetails == null) {
            availabilityDetails = new AvailabilityDetails();
        }
        return availabilityDetails;
    }

    public void setAvailabilityDetails(final AvailabilityDetails availabilityDetails) {
        this.availabilityDetails = availabilityDetails;
    }

    public EducationDetails getEducationDetails() {
        if (educationDetails == null) {
            educationDetails = new EducationDetails();
        }
        return educationDetails;
    }

    public void setEducationDetails(final EducationDetails educationDetails) {
        this.educationDetails = educationDetails;
    }

    public PersonalDetails getPersonalDetails() {
        if (personalDetails == null) {
            personalDetails = new PersonalDetails();
        }
        return personalDetails;
    }

    public void setPersonalDetails(final PersonalDetails personalDetails) {
        this.personalDetails = personalDetails;
    }

    public OtherBenefits getOtherBenefits() {

        if (otherBenefits == null) {
            otherBenefits = new OtherBenefits();
        }
        return otherBenefits;
    }

    public void setOtherBenefits(final OtherBenefits otherBenefits) {
        this.otherBenefits = otherBenefits;
    }

    public CurrentWork getCurrentWork() {
        if (currentWork == null) {
            currentWork = new CurrentWork();
        }
        return currentWork;
    }

    public void setCurrentWork(final CurrentWork currentWork) {
        this.currentWork = currentWork;
    }


    public ClaimType getClaimType() {
        return claimType;
    }

    public String getClaimantId() {
        return claimantId;
    }

    public void setClaimantId(final String claimantId) {
        this.claimantId = claimantId;
    }

    public Map<Integer, Question> getAnswers() {
        return answers;
    }

    public LocalDateTime getClaimantLatestActivity() {
        return claimantLatestActivity;
    }

    public void setClaimantLatestActivity(final LocalDateTime claimantLatestActivity) {
        this.claimantLatestActivity = claimantLatestActivity;
    }

    @Override
    public boolean equals(final Object o) {
        return reflectionEquals(this, o);
    }

    @Override
    public int hashCode() {
        return reflectionHashCode(this);
    }

    @Override
    public String toString() {
        return reflectionToString(this);
    }

}
